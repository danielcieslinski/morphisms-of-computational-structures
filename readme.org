* Morphisms of Computational Constructs

This is a narrative on how computational structures in programming languages (data structures, control constructs, deeper algebraic structures) display morphisms among them. I first came across this as as I was exploring features in computer programming languages and I kept finding out that they exhibited parallels to ideas in very different domains when their theoretical standpoint is examined. Since 1900s there have been emergent fields in mathematics like universal algebra, category theory that attempt to capture rigorously the parallels between different domains of study. These studies along with the requirement for engineering complex systems lead to setting up fields within Computer Science to examine these ideas closely. Some of them include different kinds of semantic studies (axiomatic/operational/denotational/categorical), automata theory, and complexity studies.

Trying to read through this literature and discoveries happening in Computer Science, and observing my own work with programming languages made me see how programming languages have deep connections when you go beyond the surface structure of programming language and study about how their deep structures could be related. Programming languages act as a medium for our interaction with these computational structures and each of them differ in a way they provide tractability on these structures. This repository is an attempt at capturing the (hi)story of how these emerged and a visual catalogue of what kinds of morphisms/structure preserving maps they display among each other written in a manner communicable to someone who have sensed the resonance across very different fields of computation, but would like to know if there is a meta-structure to these.

** Notes to an enthusiast

When I was young, I found people talking about ideas like Curry-Howard isomorphism or discussing the struggle about learning about monads pretty intriguing. Though, I lacked the technical know-how at that time to evaluate what was even being addressed. But as I started looking into these over a period of time, I slowly became immersed in the terminology enough to understand what was being referred to and what was at stake. If you find yourself puzzled about what all these ideas are about but are at loss on how to proceed, let me share some of the things that have helped me in gaining traction to understand them.

*** [[./how-to-learn.org][A short guide about learning these ideas]]

* Why study these?

My motivation towards studying these concepts is that they allow you to figure out the deep unity and distinction among different concepts in programming languages. Apart from programming languages, these studies also shine light on how natural language could be tied to programming languages. These I sense provide a  certain setting in which you can understand how language, grammar, mechanism, and mind are related.

Also, it is of great value in doing advancing programming methods and is being actively researched. There has been a lot of activities in these domains and it is intimidating for an entrant to understand the who, what, how and why of these. This document is my humble attempt at trying to bring a structure to the sprawling field of development so that it might help someone to make sense when undertaking a similar journey. Hope it helps!

I also keep a rough journal of how I came across the ideas [[./journal.org][here]].

And if you find any errors or have feedback, please reach out to me on [[https://twitter.com/prathyvsh][@prathyvsh]]

** Concepts under study

- Fixed Point

- Continuations: Continuations can be thought of as a construct that carries with it the context that need to be evaluated.

- Lazy Evaluation / Non-strictness: Lazy evaluation also known as non-strictness, delays the evaluation of a program and lets a user derive the values on demand.

- Actors: Actors are models of concurrency devised by Hewitt. He found the aspect of lack of time in Lambda Calculus a setback and sought to amend it with his model.

- Closures: Closures are contexts of function execution stored for computational purposes

- Algebraic Effects: Algebraic Effects allow one to build up composable continuations.

- Monads: Originally deriving from abstract algebra, where they are structures that are endofunctors with two natural transformations. Monads when used in the programming context can be thought of as a way to bring in infrastructure needed for composing functions together.

- Montague Quantification: Montague considered programming language and natural languages as being united with a universal grammar. His idea of quantification is thought to be parallel to continuations in programming languages.

- Generators/Iterators: Constructs that allows one to control the looping behaviour of a program

- *Algebraic Structures*

[[./img/birkhoff-universal-algebra.png]]

Magmas, Semigroup, Quasigroup, Loop, Monoid, Monad, Group, Abelian Groups, Ring, Fields, Lattice, Modules, Filters, Ideals, Groupoid, Setoid, Trees, Lists, Units

Algebraic structures are studied under universal/abstract algebra with each species sharing a different structural property. They can be thought of as sharing a set with certain operations that gives them a particular nature.

They have deep connections with computation as most of the structures that we deal with in computer science belongs to the algebraic species studied by mathematicians.

- Data and Co-Data

- Algebras and Co-Algebras

- Initial and Final Algebras

- Morphisms

- Recursion Schemes

- Covariance and Contravariance

- Monotonicity

* History

** Early History

The study of computation is something that has deep roots into antiquity. Keeping in mind that it is anachronistic to ascribe modern concepts to describe what our ancestors did, some proto-form of computation can be seen in the ancient divination devices used in ancient Arab culture and medieval period. The 17th, and 18th century found many great minds setting a ground for modern algebra to take roots and a significant break in the tradition can be thought of as coming from the English school of logic where algebra and logic was combined. After this period great advances where made throughout the 19th century which set the stage for the intellectual advancements of the 20th century where the idea of computation takes shape.

** The intellectual advancements of 20th century

There are several works that contributed to the emergence of computer science but some of the figures that have had a salient early influence in shaping up the idea of computation were the works of Gödel, Frege, Hilbert, Russell, Post, Turing, and Whitehead.

** Hilbert program and the birth of Lambda Calculus

Towards 1910s, a framework called Lambda Calculus was invented by Alonzo Church, inspired by Principia Mathematica. Principia Mathematica was an undertaking to ground all of mathematics in logic. It was created in response to the Hilbert program to formalize effective calculability. Lambda Calculus became one of the standard environment to do work on computation in academic circles. This inspired Scott-Strachey-Landin line of investigations to base programming language studies on it.

** Universal Algebra and Category Theory

In 1930s, work on Universal Algebra, commenced by Whitehead, were given a clarified format by mathematicians like Oysten Ore, and Garrett Birkhoff. Towards 1940s, one would see the development of Category Theory. A huge amount of intellectual advances are made from this theoretical vantage point that would contribute towards studying the morphisms between different theoretical models.

** Work post 1950s

[[./img/roger-godement.png]]

Lattice Theory, Universal Algebra, Algebraic Topology, and Category Theory became fields with intense investigation into the mathematical structure. It is during this period of intense activity that Godemont invented monads under the name “standard construction” in his work [[https://amzn.to/2ZP167s][Théorie des faisceaux (Theory of Sheaves) (1958)]].

This construction 

They used it to understand different programming language constructs popular at the time. Landin came up with operational semantics and Scott/Strachey with denotational semantics that modelled programming languages by mapping them to mathematical models.

Using these formalizations, one can start to reason about what different constructs in programming language mean (operation wise / structure preserving mapping wise) and conduct studies on them for discovering their properties and complexity parameters.

Scott set the stage for the work of semantics with his paper: [[https://www.cs.ox.ac.uk/files/3222/PRG02.pdf][Outline of a Mathematical Theory of Computation]]

Scott’s work resulted in domain theory where lambda calculus was interpreted as modelling [[https://epubs.siam.org/doi/abs/10.1137/0205037?journalCode=smjcat][continuous lattices]].
TODO: Understand how CPO figures in here

There was a flurry of work in understanding how control flow constructs work post 1960s which is documented in the work of John Reynolds (See Resources section). There ensued work on denotational models of effectful (state, control flow, I/O) and non-deterministic (concurrency/parallelism) languages.

This rise in complexity and clarity would lead to the use of topological/metric spaces to be brought to bear on studying computational structures.

[[./img/john-reynolds.png]]
In Definitional Interpreters for Higher Order Programming Languages (1972), John Reynolds brings out the relationship between Lambda Calculus, SECD, Morris-Wadsworth method and his own definition for GEDANKEN.
This work introduces the idea of defunctionalization: A method of converting a language with higher order functions into first order data structures.

Defunctionalization allows to treat programming languages as algebraic structures. In this sense, they are related to F-algebras.

Reynolds also distinguishes in this paper between trivial and serious functions which would later transform into showing the duality between values and computations. The parallel here is that values are the results that have been acquired from processes that have terminated and computations are processes that needs to be computed. This idea is emphasized in Essence of Algol (1997): https://link.springer.com/chapter/10.1007%2F978-1-4612-4118-8_4 Continuations are the term for computations that remains to be processed and defunctionalization is the method by which you turn a computation into a value and refunctionalization the reverse process. Defunctionalization, so to speak, gives a handle on the underlying computation which is active at runtime.

An important paper in this direction seems to be [[http://homepages.inf.ed.ac.uk/gdp/publications/Category_Theoretic_Solution.pdf][The Category-Theoretic Solution of Recursive Domain Equations]]

Eugenio Moggi brought together [[https://www.ics.uci.edu/~jajones/INF102-S18/readings/09_Moggi.pdf][monads and control flow constructs in Lambda Calculus]]. Moggi’s semantics was used by Philipp Wadler to simplify the API of Haskell from [[http://doi.acm.org/10.1145/143165.143169][CPS-based to monad based]].

Investigations into the computational setting for abstract algebra would see emergence of fields of study like Universal Co-algebra that captures the duality in computation and values. This is a neat table from J.J.M.M Rutten’s [[https://homepages.cwi.nl/~janr/papers/files-of-papers/universal_coalgebra.pdf][paper on Universal Coalgebra: a theory of systems]] to understand the duality between different ideas of universal algebra and universal co-algebra.
[[./img/universal-co-algebra-chart.png]]


Andrzej Filinski and Olivier Danvy worked on [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.6.960&rep=rep1&type=pdf][unifying control concepts]].

Filinski found out about Symmetric Lambda Calculus during his Ph. D. work. [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8729&rep=rep1&type=pdf][This paper]] detailed about the duality existing between values and continuations.

Expressions can be thought of as [[http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/27/slides/kenichi1.pdf][producing data and continuations as consuming data]].
Matija Pretnar uses Filinski’s representation theorem to [[https://homepages.inf.ed.ac.uk/slindley/papers/handlers.pdf][invent effect handlers]].

These works leads up to [[http://lambda-the-ultimate.org/node/4481][formalizing computational effects]] in languages like Eff and Koka.

A good bibliography of this chain can be found catalogued by Jeremy Yallop (See Resources).

** Recursion Schemes / Morphisms of F-algebras

Morphism of F-Algebras

Anamorphism: From co-algebra to a final co-algebra
Used as unfolds

Catamorphism: Initial algebra to an algebra
Used as folds

Hylomorphism: Anamorphism followed by a Catamorphism (Use Gibbons’ image)

Paramorphism: Extension of Catamorphism
Apomorphism: Extension of Anamorphism


* Resources

** Posts

*** [[https://jlongster.com/Whats-in-a-Continuation][Whats in a Continuation]]
James Longster

*** [[https://garlandus.co/OfTablesChairsBeerMugsAndComputing.html][Of Tables, Chairs, Beers Mugs and Computing]]
A really nice essay by Garlandus outlining the role of Hilbert and Göttingen in influencing the history of Computer Science

*** [[http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf][Introduction to Programming with Shift/Reset]]
Kenichi Asai, Oleg Kiselyov (2011)

*** [[http://comonad.com/reader/2009/recursion-schemes/][Recursion Schemes: A Field Guide]]
Edward Kmett (2009)

*** Introduction to Recursion Schemes [[https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html][Part 1]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-2.html][Part 2]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-3.html][Part 3]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-4.html][Part 4]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-4-point-5.html][Part 4.5]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-5.html][Part 5]], [[https://blog.sumtypeofway.com/posts/recursion-schemes-part-6.html][Part 6]]

** Talks
*** [[https://www.youtube.com/watch?v=Ssx2_JKpB3U][A Categorical View of Computational Effects]]

*** Hoare’s talks on unifying process calculus
Hoare has given a set of three talks at Heidelberg Laureate Conferences where he talks about the coherence of logic, algebra, and geometry in Computer Science

**** [[https://www.heidelberg-laureate-forum.org/video/lecture-pioneers-of-computer-science-aristotle-and-euclid.html][Talk 1: Pioneers of Computer Science: Aristotle and Euclid]]
**** [[https://www.youtube.com/watch?v=wzd8BeVpQpw][Talk 2: A finite geometric representation of computer program behaviour]]
**** [[https://www.youtube.com/watch?v=S_mmMVoSW30][Talk 3: Algebra, Logic, Geometry at the Foundation of Computer Science]]

** Surveys

*** [[http://okmij.org/ftp/continuations/][Oleg Kiselyov’s compilation on continuations]]

*** [[https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/reynolds-discoveries.pdf][Discovery of Continuations]]
John Reynolds

*** [[https://github.com/yallop/effects-bibliography][Effects Bibliography]]
Jeremy Yallop

*** [[http://comonad.com/reader/2018/computational-quadrinitarianism-curious-correspondences-go-cubical/][A catalogue of the picture emerging among the Curry-Howard-Lambek-Stone-Scott-Tarski correspondences]]
