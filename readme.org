* Morphisms of Control Constructs

This is a narrative on how control constructs in programming languages display (homo/iso)morphisms. I first came across this as I was exploring features in computer programming languages and I kept finding out that they started exhibited parallels when their theoretical standpoint is examined. Since 1900s there have been emergent fields like universal algebra and category theory that attempt to capture rigorously the parallels between different domains of study. Trying to read through these writings and observing my own work with programming languages helped me see how programming constructs have deep links in the way they make computational structures tractable. This article is an attempt at telling the (hi)story of how these emerged and what nature of morphisms/structure preserving maps they display among each other.

** Constructs under study
These are the constructs that I have observed to display morphisms.

- Continuations
Continuations can be thought of as a construct that carries with it the context that need to be evaluated.

- Lazy Evaluation / Non-strictness
Lazy evaluation also known as non-strictness, delays the evaluation of a program and lets a user derive the values on demand.

- Actors
Actors are models of concurrency devised by Hewitt. He found the aspect of lack of time in Lambda Calculus a setback and sought to amend it with his model.

- Closures
Closures are contexts of function execution stored for computational purposes

- Algebraic Effects
Algebraic Effects allow one to build up composable continuations.

- Monads
Originally deriving from abstract algebra, where they are structures that are endofunctors with two natural transformations.
Monads when used in the programming context can be thought of as a way to bring in infrastructure needed for composing functions together.

- Montague Quantification
Montague considered programming language and natural languages as being united with a universal grammar.
His idea of quantification is thought to be parallel to continuations in programming languages.

- Generators/Iterators
Constructs that allows one to control the looping behaviour of a program.


** Early pointers

Some of these connections where what drew may attention to find that there is morphisms happening across different control constructs.

** Continuations vs. Lazy Evaluation
Chris Okasaki has found the link between [[https://link.springer.com/article/10.1007/BF01019945][Lazy Evaluation / Call by Need and Continuations]].

** Closures vs. Actors
Closures — Actor isomorphism was demonstrated by Guy Steele/Dan Friedman but was [[https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf][rejected by Hewitt]].

** Montague Quantification vs. Continuations
Natural language exhibiting continuations is described by Barker [[https://www.cs.bham.ac.uk/~hxt/cw04/barker.pdf][here]] and in [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.454.8690&rep=rep1&type=pdf][this book]].

** History

Lambda Calculus was invented by Alonzo Church, inspired by Principia Mathematica, which was a logicist undertaking in response to the Hilbert programme to formalize effective calculability. Lambda Calculus became the standard environment to do work on computation in academic circles. This inspired Scott-Strachey-Landin line of investigations to base programming language studies on it.

Towards 1940s, one would see the development of Category Theory. A huge amount of intellectual advances are made from this theoretical vantage point that would contribute towards studying the morphisms between different theoretical models.

Godemont invented monads in 1958 under the name “standard constrution”.

They used it to understand different programming language constructs popular at the time. Landin came up with operational semantics and Scott/Strachey with denotational semantics that modelled programming languages by mapping them to mathematical models.

Using these formalizations, one can start to reason about what different constructs in programming language mean (operation wise / structure preserving mapping wise) and conduct studies on them for discovering their properties and complexity parameters.

Scott’s work resulted in domain theory where lambda calculus was interpreted as modelling [[https://epubs.siam.org/doi/abs/10.1137/0205037?journalCode=smjcat][continuous lattices]].
TODO: Understand how CPO figures in here

There was a flurry of work in understanding how control flow constructs work post 1960s which is documented in the work of John Reynolds (See Resources section). There ensued work on denotational models of effectful (state, control flow, I/O) and non-deterministic (concurrency/parallelism) languages.

This rise in complexity and clarity would lead to the use of topological/metric spaces to be brought to bear on studying computational structures.

An important paper in this direction seems to be [[http://homepages.inf.ed.ac.uk/gdp/publications/Category_Theoretic_Solution.pdf][The Category-Theoretic Solution of Recursive Domain Equations]]

Eugenio Moggi brought together [[https://www.ics.uci.edu/~jajones/INF102-S18/readings/09_Moggi.pdf][monads and control flow constructs in Lambda Calculus]]. Moggi’s semantics was used by Philipp Wadler to simplify the API of Haskell from [[http://doi.acm.org/10.1145/143165.143169][CPS-based to monad based]].

Andrzej Filinski and Olivier Danvy worked on [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.6.960&rep=rep1&type=pdf][unifying control concepts]].

Filinski found out about Symmetric Lambda Calculus during his Ph. D. work. [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8729&rep=rep1&type=pdf][This paper]] detailed about the duality existing between values and continuations.

Expressions can be thought of as [[http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/27/slides/kenichi1.pdf][producing data and continuations as consuming data]].
Matija Pretnar uses Filinski’s representation theorem to [[https://homepages.inf.ed.ac.uk/slindley/papers/handlers.pdf][invent effect handlers]].

These works leads up to [[http://lambda-the-ultimate.org/node/4481][formalizing computational effects]] in languages like Eff and Koka.

A good bibliography of this chain can be found catalogued by Jeremy Yallop (See Resources).

TODO: Find out how the categorical duality between expressions and continuations can be grounded using initial and final algebras and co-algebras.

TODO: Find out what how Plotkin and Power used Lawvere’s idea to model algebraic theory of effects in categorical semantics.

TODO: Find out how yield/run maps to continuations

TODO: Add Shift/Reset and Felleisen’s operator

TODO: Investigate Call by Push Value by Paul Blain Levy

* Resources

** Posts

*** [[https://jlongster.com/Whats-in-a-Continuation][Whats in a Continuation]]
James Longster

*** [[https://garlandus.co/OfTablesChairsBeerMugsAndComputing.html][Of Tables, Chairs, Beers Mugs and Computing]]
A really nice essay by Garlandus outlining the role of Hilbert and Göttingen in influencing the history of Computer Science

** Talks
*** [[https://www.youtube.com/watch?v=Ssx2_JKpB3U][A Categorical View of Computational Effects]]

** Surveys

*** [[http://okmij.org/ftp/continuations/][Oleg Kiselyov’s compilation on continuations]]

*** [[https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/reynolds-discoveries.pdf][Discovery of Continuations]]
John Reynolds

*** [[https://github.com/yallop/effects-bibliography][Effects Bibliography]]
Jeremy Yallop
